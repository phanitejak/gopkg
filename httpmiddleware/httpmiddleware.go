// Package httpmiddleware is instrumenting http router with default settings
package httpmiddleware

import (
	"encoding/json"
	"net/http"

	"github.com/phanitejak/kptgolib/metrics"
	"github.com/phanitejak/kptgolib/metrics/openapi"
	"github.com/phanitejak/kptgolib/tracing"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/getkin/kin-openapi/routers/legacy"
)

// GetSwaggerFnc is in fact api.GetSwaggerFnc.
type GetSwaggerFnc func() (*openapi3.T, error)

// New is instantiating new HTTP handler instrumented with common functionality
// si is in fact "api.Handler(si)" (call to the function generated by swagger code generator)
// gsFnc is in fact "api.GetSwagger" (the function generated by swagger code generator)
// See README.md how to use it.
func New(si http.Handler, gsFnc GetSwaggerFnc) (http.Handler, error) {
	return NewWithValidationOptions(si, gsFnc, nil)
}

// NewWithValidationOptions enables passing options for the request validation
func NewWithValidationOptions(si http.Handler, gsFnc GetSwaggerFnc, validationOptions *openapi3filter.Options) (http.Handler, error) {
	mainRouter, err := instrumentHTTPHandlers(si, gsFnc, validationOptions)
	if err != nil {
		return nil, err
	}

	handler := http.NewServeMux()
	handler.Handle("/", mainRouter)
	addMetricsEndpoints(handler)

	return handler, nil
}

// InstrumentHTTPHandlerWithTracing adds basic tracing middlewares to handler.
func InstrumentHTTPHandlerWithTracing(handler http.Handler) http.Handler {
	return tracing.Wrap(handler)
}

// addMetricsEndpoints adds metrics instrumentation for the router.
func addMetricsEndpoints(mux metrics.Router) {
	// Activate /application/prometheus endpoint and make it available at Grafana dashboard
	metricsHandler := metrics.InstrumentHTTPHandler(metrics.GetMetricsHandler())
	mux.Handle(metrics.DefaultEndPoint, metricsHandler)
	metrics.InstrumentWithPprof(mux)
}

// instrumentHTTPHandlers is adding tracing to the http requests handling
func instrumentHTTPHandlers(si http.Handler, gsFnc GetSwaggerFnc, validationOptions *openapi3filter.Options) (http.Handler, error) {
	swagger, err := gsFnc()
	if err != nil {
		return nil, err
	}

	swagger = prepareSwagger(swagger)
	siRouter, err := addValidationMiddleware(swagger, si, validationOptions)
	if err != nil {
		return nil, err
	}

	return tracing.Wrap(
		metrics.InstrumentHTTPHandlerWithRules(
			siRouter,
			openapi.ToInstrumentRulesV2(swagger),
		),
	), nil
}

// ErrResp ...
type ErrResp struct {
	Error string `json:"error,omitempty"`
}

// addValidationMiddleware is returning an HTTP handler constructor for validating requests.
func addValidationMiddleware(swagger *openapi3.T, next http.Handler, options *openapi3filter.Options) (http.Handler, error) {
	router, err := legacy.NewRouter(swagger)
	if err != nil {
		return nil, err
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		route, pathParams, err := router.FindRoute(r)
		if err != nil {
			w.Header().Add("Content-Type", "application/json")
			w.WriteHeader(http.StatusNotFound)
			_ = json.NewEncoder(w).Encode(ErrResp{Error: err.Error()})
			return
		}

		requestValidationInput := &openapi3filter.RequestValidationInput{
			Request:    r,
			PathParams: pathParams,
			Route:      route,
			Options:    options,
		}

		err = openapi3filter.ValidateRequest(r.Context(), requestValidationInput)
		if err != nil {
			w.Header().Add("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			_ = json.NewEncoder(w).Encode(ErrResp{Error: err.Error()})
			return
		}

		next.ServeHTTP(w, r)
	}), nil
}

// prepareSwagger will remove all props with type:string, forma: json setup.
// Validation middleware doesn't accept format json for string property so we need to remove those.
func prepareSwagger(s *openapi3.T) *openapi3.T {
	for _, schema := range s.Components.Schemas {
		removeStrJSONFormats(schema)
	}
	return s
}

func removeStrJSONFormats(ref *openapi3.SchemaRef) bool {
	if ref.Value == nil {
		return false
	}

	/* if ref.Value.Type == "string" && ref.Value.Format == "json" {
		return true
	} */

	if ref := ref.Value.Items; ref != nil {
		removeStrJSONFormats(ref)
	}

	for name, r := range ref.Value.Properties {
		if removeStrJSONFormats(r) {
			delete(ref.Value.Properties, name)
		}
	}
	return false
}
